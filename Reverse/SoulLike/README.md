# SoulLike

​	首先，这个题的考点是暴力跑脚本试flag的求解。 但是戏说不是胡说，改编不是乱编，即使是纯跑脚本的题目也不是仅仅可以靠强行排列组合得出来的。可见的输入字符从33到126将近100个，flag长度为10就有10^20^种可能。所以我们要让试flag的过程有迹可循。

​	关于如何复杂化这个解题的过程也是让我思考了很久。首先这个题的构造方式肯定是之前出现过的，构造一个几千条语句的运算规则然后得出正确结果。然而如何构造算法语句的过程却让我陷入了疑惑。之前做过的那个题目是利用异或的相抵消，让实际上的上千条语句中能用的部分只有去除掉异或之后的一段。但是我不想出这种题，因为构造语句的脚本写起来好麻烦啊。

​	所以之后的想法就确定为，需要解密的人一个字符一个字符地跑脚本进行尝试，最终即可尝试出正确的解。flag的每一位只用尝试100次，这样就是一个很容易的暴力解法了。那么如何实现这样的构造语句的脚本呢？首先不能是纯异或构成的算法。因为纯异或构成的算法可以将用来比较的结果直接输入，由于异或的可逆性即可得到最后的结果。同时我希望对这个的解密是逐位逐位来的，所以必须先解决前面的n-1位才能得到第n位。所以在语句中我穿插了一些与前面异或的语句，这样即可保证逆向手需要先保证前面的正确，否则过程中的值就是不正确的。

​	之后我是怎么构造的详见`source/pythonuse`文件夹下的内容。我在其中引入了累加来破坏异或后的位状态。但这个并不重要。重要的经过我的测试，我发现4000句及以上的生成伪代码时会让程序死掉，而3000句的代码块大小虽然我没细看，但应该是略高于64k的水平，这个水平下ida是能够生成伪代码的，虽然会花费较长的时间并且中途小小的无响应一下。其次就是有关ida的反编译生成伪代码的算法。当arr[a] ^= arr[b]并且这个语句的前后有++arr[b]这样的语句时,ida会将它合并成arr[a] ^= ++arr[b]这样的形式。虽然逻辑上来说没问题，但是这样让我怎么写wp啊！所以我在语句生成的代码里面对这种情况做了特判，保证反编译出来也是3000句，这样解密脚本什么的都比较好写。