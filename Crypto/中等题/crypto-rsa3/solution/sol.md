其实这道题和省赛拿到没做出来的题目考点是一样的，所以那次省赛我已经有脚本了，但是省赛题目不应该这么出，怎么到了最后变成了电脑性能的较量。。

我觉得要考费马分解应该这样出：大家可以看到，题目中的两个素数之间相隔很近，这就给费马分解提供了机会（虽然我不知道网上有没有像我一样用这个next_prime这个函数的，但是意思应该也会相近），大家可以上网查查相关资料，省赛的时候一个学弟的脚本挺不错的，还多线程。但是我当时候的脚本和他写得不一样，当然也能解出来，不过哪时间复杂度可能稍慢一些，现在给出我的脚本：

```python
import gmpy2
from Cryptodome.Util.number import *
n=177606504836499246970959030226871608885969321778211051080524634084516973331441644993898029573612290095853069264036530459253652875586267946877831055147546910227100566496658148381834683037366134553848011903251252726474047661274223137727688689535823533046778793131902143444408735610821167838717488859902242863683
c=1457390378511382354771000540945361168984775052693073641682375071407490851289703070905749525830483035988737117653971428424612332020925926617395558868160380601912498299922825914229510166957910451841730028919883807634489834128830801407228447221775264711349928156290102782374379406719292116047581560530382210049
e=65537

for b in range(0,10000):
    a=gmpy2.iroot(n+b*b,2)[0]
    if(a*a-b*b==n):
        p=a+b
        q=a-b
        break;
assert(p*q==n)
phi = (p-1)*(q-1)
d = gmpy2.invert(e,phi)
m = pow(c,d,n)
print (long_to_bytes(m))

```

我通过修改学弟的脚本也可以解决这道题

```python
import threading

def isqrt(n):
    x = n
    y = (x + n // x) // 2
    while y < x:
      x = y
      y = (x + n // x) // 2
    return x

def Fermat(num, x):
    y2 = x*x - num;
    y = isqrt(y2);
    if y*y == y2:
        print([x+y, x-y]);

if __name__ == "__main__":
    num = int(input('n='))
    x = isqrt(num)
    if x*x < num:
        x += 1
    i = 1
    while(i < 1e20):
        threads = []
        for j in range(40):
            t = threading.Thread(target = Fermat, args = (num, x))
            i += 1
            x += 1
            threads.append(t)
        for t in threads:
            t.start()
        for t in threads:
            t.join()
```

用这段代码可以在短时间内解出p,q